# Mock Exams

## OCP SE 11 Mock Exam 1

### Section 1: Core Java Concepts
1. What is the difference between == and equals() method in Java?
2. Explain the concept of method overloading and method overriding with examples.
3. How does Java support multi-threading and what are the benefits of using threads?
4. Discuss the importance of immutability in Java and how it is achieved.
5. What are the different types of access modifiers in Java and how do they impact class design?

### Section 2: Java SE 11 Features
1. Describe the enhancements made to the String class in Java SE 11.
2. How does the var keyword improve type inference in Java SE 11?
3. Explain the concept of HTTP/2 support in Java SE 11 and its advantages.
4. Discuss the changes introduced to the Optional class in Java SE 11.
5. What are the benefits of using the HttpClient class for making HTTP requests in Java SE 11?

## OCP SE 11 Mock Exam 2

### Section 3: Essential APIs
1. How does the Stream API in Java simplify data processing operations?
2. Discuss the role of the Files class in Java for file manipulation.
3. Explain the purpose of the java.util.function package and its functional interfaces.
4. What are the differences between ArrayList and LinkedList in Java collections?
5. How can developers use the java.util.concurrent package for parallel programming?

### Section 4: Concurrency
1. What are the challenges of concurrent programming and how does Java address them?
2. Describe the synchronized keyword and its role in achieving thread safety.
3. How do locks and conditions help in managing concurrent access to shared resources?
4. Discuss the Executor framework in Java and its advantages for task execution.
5. What is the significance of volatile keyword in Java concurrency?

## OCP SE 11 Mock Exam 3

### Section 5: Exception Handling
1. Explain the hierarchy of exception classes in Java and their relationships.
2. How can developers create custom exceptions in Java for specific error scenarios?
3. Discuss the try-with-resources statement and its benefits for resource management.
4. What are checked and unchecked exceptions in Java and when should they be used?
5. Provide examples of handling exceptions using try-catch and throw statements.

### Section 6: I/O Operations
1. How does Java handle input and output operations using streams and readers/writers?
2. Discuss the differences between byte stream and character stream classes in Java I/O.
3. Explain the purpose of serialization and deserialization in Java for object persistence.
4. What are the advantages of using NIO for non-blocking I/O operations in Java?
5. How can developers handle file operations efficiently using Java NIO?

